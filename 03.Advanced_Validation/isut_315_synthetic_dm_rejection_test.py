""" 
Synthetic-Data Discriminability Test (Reviewer Defense)
======================================================

Reviewer attack addressed
-------------------------
"Your pipeline may be hard-coded to prefer ISUT/MOND. Can it actually
discriminate between a baryon-coupled modified-gravity proxy and a
dark-matter halo proxy if the data were generated by the *other* model?"

This script constructs two kinds of synthetic datasets using SPARC baryonic
components as a base:

  (A) DM-synthetic:  V^2 = V_bar^2 + V_NFW^2  + noise
  (B) ISUT-synthetic: V^2 = (g_ISUT * R)      + noise, where g_ISUT = g_N * nu(y)

Then it fits both proxy models back to the synthetic data:
  - ISUT/MOND baryon-coupled proxy (parameters: ups_disk, ups_bulge)
  - NFW halo proxy (parameters: ups_disk, ups_bulge, V200, c)

We report chi2 and BIC* winners. On DM-synthetic data, the DM model should
typically win; on ISUT-synthetic data, the ISUT model should typically win.

This does NOT prove either model is "true". It is a *pipeline integrity*
check showing the code is not trivially forced to prefer ISUT.

Outputs (relative)
------------------
Creates a folder next to this script:

  03.Advanced_Validation/12.synthetic_dm_rejection_test__/
      data/synthetic_discriminability_summary.csv
      figures/example_<gal>_<kind>.png
      logs/run_metadata.json

Run
---
    python 03.Advanced_Validation/12.synthetic_dm_rejection_test__.py --nrep 25 --seed 0
"""

from __future__ import annotations

import argparse
import os
from pathlib import Path
from typing import Dict, List, Tuple

import numpy as np

try:
    import pandas as pd
except Exception as e:  # pragma: no cover
    raise RuntimeError("pandas is required for this script") from e

import matplotlib.pyplot as plt

from scipy.optimize import minimize

# --- ISUT shared helpers ---
import sys

REPO_ROOT = Path(__file__).resolve().parents[1]
if str(REPO_ROOT) not in sys.path:
    sys.path.insert(0, str(REPO_ROOT))

from isut_000_common import ScriptPaths, find_sparc_data_dir, ensure_rotmod_file, write_run_metadata


# -----------------------------
# Units / constants
# -----------------------------

ACCEL_CONV = 3.24078e-14  # 1 (km/s)^2/kpc -> m/s^2
A0_SI_DEFAULT = 1.2e-10


def nu_simple(y: np.ndarray) -> np.ndarray:
    y = np.maximum(y, 1e-30)
    return 0.5 * (1.0 + np.sqrt(1.0 + 4.0 / y))


def nu_standard(y: np.ndarray) -> np.ndarray:
    y = np.maximum(y, 1e-30)
    return np.sqrt(0.5 * (1.0 + np.sqrt(1.0 + 4.0 / (y**2))))


def load_rotmod(path: Path) -> Tuple[np.ndarray, ...]:
    df = pd.read_csv(path, sep=r"\s+", comment="#", header=None)
    df = df.apply(pd.to_numeric, errors="coerce").dropna()
    if df.shape[1] < 6:
        raise ValueError(f"Unexpected rotmod format: {path} (ncol={df.shape[1]})")
    R = df.iloc[:, 0].to_numpy(float)
    Vobs = df.iloc[:, 1].to_numpy(float)
    Verr = df.iloc[:, 2].to_numpy(float)
    Vgas = df.iloc[:, 3].to_numpy(float)
    Vdisk = df.iloc[:, 4].to_numpy(float)
    Vbul = df.iloc[:, 5].to_numpy(float)
    return R, Vobs, Verr, Vgas, Vdisk, Vbul


def v_bary2(Vgas: np.ndarray, Vdisk: np.ndarray, Vbul: np.ndarray, ups_d: float, ups_b: float) -> np.ndarray:
    Vb2 = (np.abs(Vgas) * Vgas) + (ups_d * np.abs(Vdisk) * Vdisk) + (ups_b * np.abs(Vbul) * Vbul)
    return np.maximum(Vb2, 0.0)


def v_nfw2(R_kpc: np.ndarray, V200: float, c: float) -> np.ndarray:
    """Return V^2 for an NFW halo proxy.

    This matches the functional form used elsewhere in the repo (battle scripts):
      V(r) = V200 * sqrt( (ln(1+c x) - c x/(1+c x)) / (x * (ln(1+c)-c/(1+c))) )
    with x = r / R200 (we absorb R200 into scale via x ~ r / 200kpc proxy).

    Note: This is a *proxy* and not a full cosmology-calibrated halo model.
    """
    # Use a simple scale: treat R200 ~ 200 kpc (order-of-magnitude proxy)
    R200 = 200.0
    x = np.maximum(R_kpc / R200, 1e-6)

    def f(z: np.ndarray) -> np.ndarray:
        return np.log(1.0 + z) - z / (1.0 + z)

    denom = f(np.array([c], dtype=float))[0]
    denom = max(denom, 1e-12)
    num = f(c * x)
    V2 = (V200**2) * (num / (x * denom))
    return np.maximum(V2, 0.0)


def predict_isut(R: np.ndarray, Vgas: np.ndarray, Vdisk: np.ndarray, Vbul: np.ndarray,
                 ups_d: float, ups_b: float, a0_code: float, nu_fn) -> np.ndarray:
    Vb2 = v_bary2(Vgas, Vdisk, Vbul, ups_d, ups_b)
    gN = Vb2 / np.maximum(R, 0.01)
    y = gN / a0_code
    g = gN * nu_fn(y)
    V2 = g * R
    return np.sqrt(np.maximum(V2, 0.0))


def predict_dm(R: np.ndarray, Vgas: np.ndarray, Vdisk: np.ndarray, Vbul: np.ndarray,
               ups_d: float, ups_b: float, V200: float, c: float) -> np.ndarray:
    Vb2 = v_bary2(Vgas, Vdisk, Vbul, ups_d, ups_b)
    Vdm2 = v_nfw2(R, V200, c)
    return np.sqrt(np.maximum(Vb2 + Vdm2, 0.0))


def chi2(Vobs: np.ndarray, Vpred: np.ndarray, Verr: np.ndarray) -> float:
    sig = np.maximum(Verr, 1e-3)
    r = (Vobs - Vpred) / sig
    return float(np.sum(r**2))


def bic_star(chi2_val: float, k: int, n: int) -> float:
    return float(chi2_val + k * np.log(max(n, 1)))


def fit_isut(R, Vsyn, Verr, Vgas, Vdisk, Vbul, a0_code, nu_fn) -> Tuple[Dict[str, float], float, float]:
    def obj(p):
        ups_d, ups_b = p
        Vp = predict_isut(R, Vgas, Vdisk, Vbul, ups_d, ups_b, a0_code, nu_fn)
        return chi2(Vsyn, Vp, Verr)

    x0 = np.array([0.5, 0.7])
    bounds = [(0.05, 2.0), (0.05, 3.0)]
    res = minimize(obj, x0, method="L-BFGS-B", bounds=bounds)
    best = {"ups_disk": float(res.x[0]), "ups_bulge": float(res.x[1])}
    c2 = float(res.fun)
    bic = bic_star(c2, k=2, n=len(R))
    return best, c2, bic


def fit_dm(R, Vsyn, Verr, Vgas, Vdisk, Vbul) -> Tuple[Dict[str, float], float, float]:
    def obj(p):
        ups_d, ups_b, V200, c = p
        Vp = predict_dm(R, Vgas, Vdisk, Vbul, ups_d, ups_b, V200, c)
        return chi2(Vsyn, Vp, Verr)

    x0 = np.array([0.5, 0.7, 150.0, 10.0])
    bounds = [(0.05, 2.0), (0.05, 3.0), (10.0, 500.0), (1.0, 50.0)]
    res = minimize(obj, x0, method="L-BFGS-B", bounds=bounds)
    best = {"ups_disk": float(res.x[0]), "ups_bulge": float(res.x[1]), "V200": float(res.x[2]), "c": float(res.x[3])}
    c2 = float(res.fun)
    bic = bic_star(c2, k=4, n=len(R))
    return best, c2, bic


def main(argv: List[str] | None = None) -> int:
    ap = argparse.ArgumentParser(description="Synthetic DM vs ISUT discriminability test")
    ap.add_argument("--galaxies", nargs="*", default=["NGC3198", "NGC6503", "NGC2403"],
                    help="Galaxies to test (default: 3 representative galaxies)")
    ap.add_argument("--nrep", type=int, default=25, help="Replicates per galaxy per synthetic type")
    ap.add_argument("--seed", type=int, default=0)
    ap.add_argument("--nu", choices=["simple", "standard"], default="simple")
    ap.add_argument("--a0_si", type=float, default=A0_SI_DEFAULT)
    ap.add_argument("--noise_scale", type=float, default=1.0, help="Multiply SPARC errors by this factor")
    ap.add_argument("--no_download", action="store_true")
    args = ap.parse_args(argv)

    sp = ScriptPaths.for_script(__file__)
    rng = np.random.default_rng(args.seed)

    allow_download = (not args.no_download) and (os.environ.get("ISUT_NO_DOWNLOAD", "0") != "1")
    sparc_dir = find_sparc_data_dir(sp.script_dir)

    a0_code = args.a0_si / ACCEL_CONV
    nu_fn = nu_simple if args.nu == "simple" else nu_standard

    rows: List[Dict[str, float | str]] = []

    example_done = False

    for gal in args.galaxies:
        rotmod = ensure_rotmod_file(gal, sparc_dir, allow_download=allow_download)
        R, _, Verr0, Vgas, Vdisk, Vbul = load_rotmod(rotmod)
        Verr = np.maximum(args.noise_scale * Verr0, 1e-3)

        # True baryonic scaling used to synthesize
        ups_true_d, ups_true_b = 0.5, 0.7
        Vb2_true = v_bary2(Vgas, Vdisk, Vbul, ups_true_d, ups_true_b)
        gN_true = Vb2_true / np.maximum(R, 0.01)

        # --- (A) DM-synthetic ---
        for rep in range(args.nrep):
            V200 = float(rng.uniform(40.0, 300.0))
            c = float(rng.uniform(4.0, 25.0))
            Vsyn = np.sqrt(np.maximum(Vb2_true + v_nfw2(R, V200, c), 0.0))
            Vsyn_noisy = Vsyn + rng.normal(0.0, Verr)

            best_isut, c2_isut, bic_isut = fit_isut(R, Vsyn_noisy, Verr, Vgas, Vdisk, Vbul, a0_code, nu_fn)
            best_dm, c2_dm, bic_dm = fit_dm(R, Vsyn_noisy, Verr, Vgas, Vdisk, Vbul)

            winner = "DM" if bic_dm < bic_isut else "ISUT"
            rows.append({
                "galaxy": gal,
                "kind": "DM_synthetic",
                "rep": rep,
                "true_V200": V200,
                "true_c": c,
                "chi2_isut": c2_isut,
                "chi2_dm": c2_dm,
                "bic_isut": bic_isut,
                "bic_dm": bic_dm,
                "winner": winner,
            })

            if not example_done and rep == 0:
                # Example plot
                Vp_isut = predict_isut(R, Vgas, Vdisk, Vbul, best_isut["ups_disk"], best_isut["ups_bulge"], a0_code, nu_fn)
                Vp_dm = predict_dm(R, Vgas, Vdisk, Vbul, best_dm["ups_disk"], best_dm["ups_bulge"], best_dm["V200"], best_dm["c"])
                plt.figure(figsize=(9, 5))
                plt.errorbar(R, Vsyn_noisy, yerr=Verr, fmt="k.", alpha=0.55, label="Synthetic obs (DM)")
                plt.plot(R, Vp_isut, lw=2, label="Fit: ISUT")
                plt.plot(R, Vp_dm, lw=2, label="Fit: DM (NFW)")
                plt.xlabel("R [kpc]")
                plt.ylabel("V [km/s]")
                plt.title(f"Example DM-synthetic discriminability â€” {gal}")
                plt.grid(alpha=0.25)
                plt.legend()
                fig_path = sp.fig_dir / f"example_{gal}_DM_synthetic.png"
                plt.tight_layout()
                plt.savefig(fig_path, dpi=160)
                plt.close()
                example_done = True

        # --- (B) ISUT-synthetic ---
        for rep in range(args.nrep):
            g_isut = gN_true * nu_fn(np.maximum(gN_true / a0_code, 1e-30))
            Vsyn = np.sqrt(np.maximum(g_isut * R, 0.0))
            Vsyn_noisy = Vsyn + rng.normal(0.0, Verr)

            best_isut, c2_isut, bic_isut = fit_isut(R, Vsyn_noisy, Verr, Vgas, Vdisk, Vbul, a0_code, nu_fn)
            best_dm, c2_dm, bic_dm = fit_dm(R, Vsyn_noisy, Verr, Vgas, Vdisk, Vbul)

            winner = "ISUT" if bic_isut < bic_dm else "DM"
            rows.append({
                "galaxy": gal,
                "kind": "ISUT_synthetic",
                "rep": rep,
                "true_V200": np.nan,
                "true_c": np.nan,
                "chi2_isut": c2_isut,
                "chi2_dm": c2_dm,
                "bic_isut": bic_isut,
                "bic_dm": bic_dm,
                "winner": winner,
            })

    df = pd.DataFrame(rows)
    out_csv = sp.data_dir / "synthetic_discriminability_summary.csv"
    df.to_csv(out_csv, index=False)

    # Summary stats
    summary = (
        df.groupby(["kind", "winner"]).size().rename("count").reset_index()
        .pivot(index="kind", columns="winner", values="count").fillna(0)
    )
    summary_path = sp.data_dir / "synthetic_discriminability_counts.csv"
    summary.to_csv(summary_path)

    write_run_metadata(
        sp.log_dir,
        args={
            "galaxies": args.galaxies,
            "nrep": args.nrep,
            "seed": args.seed,
            "nu": args.nu,
            "a0_si": args.a0_si,
            "noise_scale": args.noise_scale,
            "allow_download": allow_download,
            "sparc_dir": str(sparc_dir),
        },
        notes={
            "baryonic_synthesis": {"ups_disk": 0.5, "ups_bulge": 0.7},
            "priors": {"V200": "U(40,300)", "c": "U(4,25)"},
            "files": {
                "summary": str(out_csv.relative_to(sp.out_root)),
                "counts": str(summary_path.relative_to(sp.out_root)),
            },
        },
    )

    print(f"[OK] Wrote: {out_csv}")
    print(f"[OK] Wrote: {summary_path}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
